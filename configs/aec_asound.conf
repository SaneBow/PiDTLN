pcm.loopback_out {
  @args [ SUBDEVICE ]
  @args.SUBDEVICE { type integer }
  type dmix
  ipc_key 10009
  hw_ptr_alignment rounddown
  slave.pcm {
    type hw
    card "Loopback"
    device 0
    subdevice $SUBDEVICE
  }
  slave {
    period_size 128
    buffer_size 4096
    format S16_LE
    rate 16000
    channels 1
  }
}

pcm.loopback_in {
  @args [ SUBDEVICE ]
  @args.SUBDEVICE { type integer }
  type dsnoop
  ipc_key 20009
  hw_ptr_alignment rounddown
  slave.pcm {
    type hw
    card "Loopback"
    device 1
    subdevice $SUBDEVICE
  }
  slave {
    period_size 128     # this is important, otherwise portaudio behaves weirdly
    buffer_size 4096
    format S16_LE
    rate 16000
    channels 1
  }
}

# audio play to this device will be duplicated to hw (stereo) and loopback (mono)
pcm.mloopplay {
  @args [ CARD LOOPIDX ]
  @args.CARD { 
    type string 
    default {
      @func refer
      name defaults.pcm.card
    }
  }
  @args.LOOPIDX {
    type integer
    default 4 
  }
  type route
  slave.pcm {
    type multi
    slaves.a.pcm {
      type hw
      card $CARD
    }
    slaves.a.channels 2
    slaves.b.pcm {  # loopback null sink
      @func concat
      strings [ "loopback_out:" $LOOPIDX ]
    }
    slaves.b.channels 1
    bindings.0.slave a
    bindings.0.channel 0
    bindings.1.slave a
    bindings.1.channel 1
    bindings.2.slave b
    bindings.2.channel 0
  }
  slave.channels 3
  ttable.0.0 1
  ttable.1.1 1
  ttable.0.2 0.5
  ttable.1.2 0.5
}

# combine mic (ch 0) and loopback (ch 1) to single recording
pcm.mlooprec {
  @args [ CARD LOOPIDX ]
  @args.CARD { 
    type string 
    default {
      @func refer
      name defaults.pcm.card
    }
  }
  @args.LOOPIDX {
    type integer
    default 4 
  }
  type route
  slave.pcm {
    type multi
    slaves.a.pcm {
      type hw
      card $CARD
    }    
    slaves.a.channels 2
    slaves.b.pcm {  # loopback capturing interface
      @func concat
      strings [ "loopback_in:" $LOOPIDX ]
    }
    slaves.b.channels 1
    bindings.0.slave a
    bindings.0.channel 0
    bindings.1.slave a
    bindings.1.channel 1
    bindings.2.slave b
    bindings.2.channel 0
  }
  slave.channels 3
  ttable.0.0 0.5
  ttable.0.1 0.5
  ttable.1.2 1
}

pcm.aec_internal {
  @args [ CARD PRELOOPIDX POSTLOOPIDX ]
  @args.CARD { 
    type string 
    default {
      @func refer
      name defaults.pcm.card
    }
  }
  @args.PRELOOPIDX {
    type integer
    default 4 
  }
  @args.POSTLOOPIDX {
    type integer
    default 5
  }
  type asym
  capture.pcm {  # -i for aec script
    type plug
    slave.pcm {
      @func concat 
      strings [ "mlooprec:" $CARD "," $PRELOOPIDX ]
    }
  }  
  playback.pcm {   # -o for aec script
    @func concat
    strings [ "loopback_out:" $POSTLOOPIDX ]
  }
}

pcm.aec {
  @args [ CARD PRELOOPIDX POSTLOOPIDX ]
  @args.CARD { 
    type string 
    default {
      @func refer
      name defaults.pcm.card
    }
  }
  @args.PRELOOPIDX {
    type integer
    default 4 
  }
  @args.POSTLOOPIDX {
    type integer
    default 5
  }
  type asym
  playback.pcm {
    type plug
    slave.pcm {
      @func concat 
      strings [ "mloopplay:" $CARD "," $PRELOOPIDX ]
    }
  }   
  capture.pcm {
    @func concat
    strings [ "loopback_in:" $POSTLOOPIDX ]
  }
}
